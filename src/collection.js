// Generated by CoffeeScript 1.6.3
/**
 * Collection
 * ==========
 * 
 * Collection is an natural javascript object with documents
 *
*/

var Collection, Doc, Document, collectionName, db, genId, inMemoryOnly, schema, util;

util = require('util');
Document = require('./document');

genId = function() {
	return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function( c ){
		var r, v;
		r = Math.random() * 16 | 0;
		v = c === 'x' ? r : r & 0x3 | 0x8;
		return v.toString(16);
	});
};

inMemoryOnly = false;
schema = false;

/**
	 * Collection constructor
	 * @param  {String} collectionName      name of collection
	 * @param  {Object} database        database to insert this new collection into, if `null` Collection will be treated as an orphan, but it will have a virtual database for itself
	 * @param  {Object} options         Object with options
	 * @param  {Boolean} options.inMemoryOnly if `true` collection is not persistant
	 * @param  {Object} options.schema      Schema for validation and relationships
	 * @param  {Object} options.initData    data to initialize collection
	 * @param  {Function} callback        signature error, collectionItself
*/

Collection = function( name, database, options ){
	var id, opts, initData;
	collectionName = name;
	db = database;
	opts = options || {};
	if (opts.inMemoryOnly) {
		inMemoryOnly = opts.inMemoryOnly;
	}
	if (opts.initData == null) {
		opts.initData = {};
	}
	initData = opts.initData;
	for (id in initData) {
		this[id] = initData[id];
	}
	Doc = Document(this);
	db[collectionName] = this;
}

Collection.prototype.Document = (function() {
	return Doc;
})();

Collection.prototype.getDb = function() {
	return database;
};

Collection.prototype.getInMemoryOnly = function() {
	return inMemoryOnly;
};

/**
	 * Adds a new schema to `Collection.schema` and compiles its validator
	 * @param {Object}   schemamodel structure model
	 * @param {Function} callback
	 * @return {Object} processed schema after extend the old one
*/
Collection.prototype.setSchema = function(newSchema, callback) {
	if (typeof newSchema === 'object') {
		schema = newSchema;
		if (callback) {
			callback(null, schema);
		} else {
			return schema;
		}
	} else {
		if (callback) {
			callback('not valid schema');
		} else {
			return false;
		}
	}
};

Collection.prototype.getSchema = (function() {
	return schema;
})();

Collection.prototype.updateSchema = function() {};

/**
	 * Insert new document/s in collection
	 * @param  {Object||Array}    docs     document/s to be stored
	 * @param  {Function} callback  signature: error, insertedDocumentsIds
	 * @return {Array}              list of inserted document ids
*/
Collection.prototype.insert = function(data, callback) {
	var docs, i, id, ids, _i, _len;
	if (typeof data === 'object') {
		if (data.length === undefined) {
			id = genId();
			if (inMemoryOnly) {
				this[id] = data;
				callback ? callback( null, this[id] ) : return this[id];
			} else {
				db._datastore().insertDoc( collectionName, id, data, function( err ){
					if (err) {
						callback ? callback( err ) : return [];
					} else {
						this[id] = data;
						callback ? callback( null, this[id] ) : return this[id];
					}
				});
			}
		} else if (typeof data.length === 'number') {
			if (inMemoryOnly) {
				ids = [];
				for (_i = 0, _len = data.length; _i < _len; _i++) {
					i = data[_i];
					ids[i] = genId();
					this[ids[i]] = data[i];
				}
				callback ? callback(null, ids) : return ids;
			} else {

			}
			docs = this.findByIds(ids);
			if (callback) {
				callback(null, docs);
			}
			return docs;
		}
	}
};

/**
	 * Find a document by identifier
	 * @param  {String}   id       
	 * @param  {Function} callback signature: error, resultDocument
	 * @return {Object}            resultDocument
*/
Collection.prototype.get = function( id, callback ){
	var doc;
	if (typeof id === 'string') {
		if (this[id]) {
			doc = new Doc( this[id] );
			callback ? callback( null, doc ) : return doc;
		} else {
			callback ? callback( 'document not found' ) : return {};
		}
	} else {
		callback ? callback( 'not valid identifier' ) : return {};
	}
};


/**
	 * Clean a document by identifier and sets its new data
	 * @param {String}   id       id of object to update
	 * @param {Object}   newDoc   new fields for document
	 * @param {Function} callback signature: error, newDoc
*/
Collection.prototype.set = function(id, newDoc, callback) {
	var doc, prop, value;
	if (this[id]) {
		delete newDoc._id;
		for (prop in newDoc) {
			value = newDoc[prop];
			if (typeof value !== 'function') {
				this[id][prop] = value;
			}
		}
		doc = new Doc( this[id] );
		callback ? callback( null, doc ) : return doc;
	} else {
		callback ? callback( 'Document not found' ) : return null;
	}
};

/**
	 * Find documents in collection
	 * @param  {Object}   query    nedb query object
	 * @param  {Function} callback signature: err, doc/s
	 * @return {Object||Array}            doc/docs
*/
Collection.prototype.find = function(query, callback) {
	var dev, doc, id, key, ok, prop, queryOn, result, value, _ref;
	query = query || false;
	queryOn = false;
	for (prop in query) {
		queryOn = true;
		break;
	}
	if ((query === false) || (queryOn === false)) {
		if (callback) {
			callback(null, this);
		}
		return this;
	} else if (typeof query !== 'object') {
		callback('Bad query');
	} else {
		result = [];
		for (id in this) {
			doc = this[id];
			if (typeof doc == 'function') {
				continue;
			}
			ok = false;
			for (prop in query) {
				value = query[prop];
				if (query.hasOwnProperty( prop )) {
					if (typeof value === 'object') {
						for (key in value) {
							if (value.hasOwnProperty(key)) {
								if (compare[key]( value[key], doc[prop] )) {
									ok = true;
								}
								break;
							}
						}
						if (ok === false) {
							break;
						}
					} else {
						if ((typeof value === 'string') || (typeof value === 'number') || (typeof value === 'boolean')) {
							if (value === doc[prop]) {
								ok = true;
							}
						}
					}
				}
			}
			if (ok === true) {
				dev = {};
				_ref = this[id];
				for (prop in _ref) {
					value = _ref[prop];
					dev[prop] = this[id][prop];
				}
				dev._id = id;
				result.push(new Doc(dev));
			}
		}
		if (callback) {
			callback(null, result);
		}
		return result;
	}
};

/**
	 * Return the first document of a search
	 * @param  {Object}   query    a nedb query formatted
	 * @param  {Function} callback signature: error, resultDocument
	 * @return {Object}            resultDocument
*/


Collection.prototype.findOne = function( query, callback ){
	var _this = this;
	this.dS.findOne(query, function(err, doc) {
		if (err) {
			callback ? callback( err ) : return {};
		} else {
			callback ? callback(null, new Doc(doc)) : return doc;
		}
	});
};

/**
	 * Update documents that match into query with update data
	 * @param  {Object}   query    nedb query formatted query
	 * @param  {Object}   update   data to update matched documents
	 * @param  {Boolean}   multi  allows the modification of several documents
	 * @param  {Function} callback signature: err, numReplaced
	 * @return {Object||Array}            updated document
*/
Collection.prototype.update = function( query, update, callback ){
	this.find( query, function( err, docs ){} );
};

/**
	 * Remove document from collection
	 * @param  {Object}   query    nedb query formatted query
	 * @param  {Function} callback signature: err, numRemoved
	 * @return {Number}            numRemoved
*/


Collection.prototype.remove = function( query, callback ){
	var _this = this;
	this.find( query, function( err, docs ){
		var doc, i, len;
		for (i = 0, len = docs.length; i < len; i++) {
			doc = docs[i];
			delete _this[doc.id];
		}
		callback ? callback( null, docs.length ) : return docs.length;
	});
};

/**
	 * Remove document by id from collection
	 * @param  {String}   id       id of target doc
	 * @param  {Function} callback signature: error, removedDocumentId
	 * @return {String}            removed document id
*/
Collection.prototype.removeById = function(id, callback) {
	if (typeof id === 'string' && this[id]) {
		delete this.id;
		if (callback) {
			callback(null, id);
		}
		return id;
	} else {
		if (callback) {
			callback('Document not found');
		}
		return 0;
	}
};

/**
	 * Remove all documents of collection
	 * @param  {Function} callback numRemoved
	 * @return {Number}            numRemoved
*/


Collection.prototype.clean = function(callback) {};


module.exports = (function (){ return Collection }) ();
